---
title: "Longitudinal aPCoA"
author: "Simeng Li"
date: "2025-09-26"
output: pdf_document
---

```{r}
library(bindata)
library(GENESIS)
library(dplyr)
library(ggplot2)
library(Matrix)
library(nlme)
library(lme4)
library(Tjazi)
library(cowplot)
library(rqpd)
library(quantreg)
library(zCompositions)
library(compositions)
```

```{r}
# SL 9.26: Same as MiRKAT
D2K <- function(D)
{
  n <- nrow(D)
  centerM <- diag(n) - 1/n
  K <- -0.5 * centerM %*% (D * D) %*% centerM # Gower Centering
  eK <- eigen(K, symmetric = TRUE)
  K <- eK$vector %*% diag(pmax(0, eK$values)) %*% t(eK$vector) # SL 10.5: pmax(0,..) ensure PSD
  return(K)
}
```

```{r}
# Adapted from Amarise's code2
# Function to produce K* (last step)
process_resids <- function(resids, otu_tmp, cond, batchid)
{
  eigen <- eigen(tcrossprod(resids), symmetric = TRUE)
  mK <- which(eigen$values > 1e-9) # keep positive values
  PCs <- eigen$vectors[,mK] %*% diag(sqrt(eigen$values[mK]))/1
  PCs <- as.data.frame(cbind(patient.id = otu_tmp$patient.id,
                             time = otu_tmp$time,
                             treatment = rep(cond, each = max(otu_tmp$time)),
                             batch = rep(batchid, each = max(otu_tmp$time)),
                             PCs))
  names(PCs)[5:ncol(PCs)] <- c(paste0('PC',1:(ncol(PCs)-4)))
  return(list(PCs = PCs,
              PC1_perc = eigen$values[1]/sum(eigen$values[mK]),
              PC2_perc = eigen$values[2]/sum(eigen$values[mK])))
}
```

# Simulation setup
```{r}
load("mom_270.Rdata")
otu_original <- t(otu)
p <- ncol(otu_original)
n = 100 
m = 4

# change condition taxa
set.seed(1)
# introduce changes in the community profiles shared by all subjects
cond_taxa1 <- sample(setdiff(1:p, id), 20)
# Treatment group, could have both sex and treatment effects
cond_taxa2 <- sample(setdiff(1:p, cond_taxa1), 20) 

set.seed(7711)
selected_samples <- sample.int(nrow(otu_original), n)

cond <- rbinom(n, 1, 0.5) # treatment/control
batchid <- rbinom(n, 1, 0.5) # sex

# perturb independent draws of taxa counts for each sample
otu_tmp <- matrix(nrow = n*m, ncol = p+2)
otu_tmp <- as.data.frame(otu_tmp)
names(otu_tmp) <- c('patient.id','time',paste0('taxa',1:p))
otu_tmp$patient.id <- rep(1:n, each = m)
otu_tmp$time <- 1:m

# Initialize taxa counts
for (i in 1:n) {
  otu_tmp[(i-1)*m + 1, 3:(p+2)] <- bayesm::rdirichlet(otu_original[selected_samples[i],] + 0.5) *
    sum(otu_original[selected_samples[i],])
}

cond_effect <- c(0.25)
batch_effect <- c(200)
sub_fc <- ifelse(cond == 1, 6*rlnorm(n, meanlog = log(5), sdlog = 1.2), 1) # mean=31.5, median=12.1, max=558.5

for (i in 1:n)
{
  for (j in 2:m)
  {
    # perturb previous time points' measurement to create current time point measurements
    otu_tmp[((i-1)*m + j), 3:(p+2)] <- bayesm::rdirichlet(as.numeric(otu_tmp[((i-1)*m + j - 1), 3:(p+2)] + 0.5)) *
      sum(otu_tmp[((i-1)*m + j - 1), 3:(p+2)])
    otu_tmp[((i-1)*m + j), (cond_taxa1 + 2)] <- otu_tmp[((i-1)*m + j), (cond_taxa1 + 2)] * cond_effect[1]
    
    if (cond[i]) # for treated subjects only
    {
      otu_tmp[((i-1)*m + j), (cond_taxa2 + 2)] <- otu_tmp[((i-1)*m + j), (cond_taxa2 + 2)] * sub_fc[i]
    }
    if (batchid[i]) # for female only
    {
      otu_tmp[((i-1)*m + j), (id + 2)] = otu_tmp[((i-1)*m + j), (id + 2)] * batch_effect[1]
    }
  }
}
otu_tmp_unrounded <- otu_tmp
otu_tmp <- round(otu_tmp)

example_data <- list(metadata = cbind(otu_tmp[,1:2],
                                      batch = rep(batchid, each = m),
                                      treatment = rep(cond, each = m)) %>%
                       rename(subjectid=`patient.id`),
                     otu_counts = otu_tmp[,3:ncol(otu_tmp)])
# save(example_data, file = "example_data.RData")
```

# Construct Aitchison Kernel and extract PCs
```{r}
# Construct D
rel_tmp <- otu_tmp[,3:ncol(otu_tmp)]/rowSums(otu_tmp[,3:ncol(otu_tmp)])
#rel_tmp_clr <- clr_lite(otu_tmp[,3:ncol(otu_tmp)], samples_are = "rows", method = "logunif", replicates = 100)

# SL 9.26: Compute the corresponding CLR (centered log-ratio) transformed abundance (Amarise used clr_lite)
imputed = cmultRepl(rel_tmp, suppress.print = TRUE) # impute zero
rel_tmp_clr = as.matrix(clr(imputed))

# Construct K
K <- D2K(as.matrix(dist(rel_tmp_clr)))
K_eigen <- eigen(K, symmetric = T)

# SL 9.26: Adapted Amarise's code
# mK <- which(K_eigen$values > 1e-9) is (numerically) the set of positive eigenvalues. For a PSD kernel, the count of positive eigenvalues equals rank(K)
mK <- which(K_eigen$values > 1e-9) 

# Retain the top ℓ ≤ rank(K) kernel PCs that explain a large proportion of the variability in K
mK90 <- min(which(cumsum(K_eigen$values[mK]/sum(K_eigen$values[mK])) > 0.9))
PCs <- K_eigen$vectors[ ,1:mK90] %*% diag(sqrt(K_eigen$values[1:mK90]))
```

############### Model 1: linear regression ###################
```{r}
stand.marg.resids <- marg.resids <- cond.resids <- matrix(NA, nrow = nrow(PCs), ncol = ncol(PCs))

for (j in 1:ncol(PCs)) {
  dat <- data.frame(y = PCs[,j],
                    time = otu_tmp$time,
                    batch = rep(batchid, each = m),
                    id = rep(1:n, each = m))
  model1 <- lmer(y ~ batch*time + (1 | id), dat)
  if (isSingular(model1)) next
  var.d <- crossprod(getME(model1,"Lambdat")) # relative random-effects covariance-covariance matrix G
  Zt <- getME(model1, "Zt") # random effects design
  vr <- sigma(model1)^2 # estimated residual variance
  var.b <- vr * (crossprod(Zt, var.d) %*% Zt) # Random-effects contribution to the marginal variance ZtGZt^T
  sI <- vr * Diagonal(nrow(dat)) # Noise variance R_i = sigma2I
  var.y <- var.b + sI # Full marginal covariance
  cholVarInv <- solve(t(chol(var.y)))
  
  # Step 5: obtain standardized residuals
  marg.resids[, j] <- dat$y - model.matrix(model1) %*% summary(model1)$coefficients[,1]
  stand.marg.resids[, j] <- as.numeric(cholVarInv %*% marg.resids[, j])
  cond.resids[, j] <- unname(residuals(model1))
}

resid_PCs <- lapply(list(marg.resids, cond.resids, stand.marg.resids),
                    function(x) process_resids(x, otu_tmp, cond, batchid))
```

```{r}
annotations <- data.frame(
  time = c(1, 2, 3, 4),  # Facet labels
  label = c("t[0]", "t[1]", "t[2]", "t[3]"),  # Custom labels
  x = c(-Inf, -Inf, -Inf, -Inf),  # x position (left side)
  y = c(Inf, Inf, Inf, Inf)  # y position (top side)
)

p_final1 <- resid_PCs[[3]]$PCs %>%
  mutate(Sex = ifelse(batch == 1, "Female", "Male")) %>%
  mutate(Arm = factor(ifelse(treatment == 0,'Control',"Treatment"), levels = c("Treatment","Control"))) %>%
  ggplot(aes(PC1, PC2, color = Arm, shape = `Sex`, group = `Sex`)) +
  geom_point(size = 2) +
  facet_wrap(~time, nrow = 2, scales = 'free',
             labeller = label_bquote(t[.(time-1)])) +
  theme(strip.text = element_blank()) +
  xlab(paste0('PC1 (', round(100*resid_PCs[[3]]$PC1_perc,2),'%)')) +
  ylab(paste0('PC2 (', round(100*resid_PCs[[3]]$PC2_perc,2),'%)')) +
  theme(plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
        legend.background = element_blank(), #transparent legend bg
        legend.box.background = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18)) +
  ggtitle('Standardized Marginal Residual PCA') +
  stat_ellipse(aes(group = `Sex`, lty = `Sex`)) +
  geom_text(data = annotations, aes(x = x, y = y, label = label),
            hjust = -0.2, vjust = 1.5, parse = TRUE, inherit.aes = FALSE)
p_final1
```

############### Model 2: quantile regression ####################
```{r}
colnames(PCs)[1:mK90] <- paste0("PC", 1:mK90)
df <- cbind(example_data$metadata, PCs)

#q <- 299
#taus <- ppoints(q + 2)[2:(q + 1)]
#tauw <- rep(1/q, q)            
lambda <- 0.25
q <- 99 # quantiles
#lambda <- 10 # penalty parameter controlling the shrinkage
tauw <- rep(1/q, q)
taus <- seq(0.01, 0.99, length.out = q)

formula <- "batch + time + batch*time"
subject_id <- "subjectid"
covariates <- c("all")
df$subjectid <- factor(df$subjectid)
quantiles <- seq(0.01, 0.99, length.out = q)

PC_hat_list <- list()

for (pc in colnames(PCs)) {
  cat("Processing", pc, "...\n")

  formula_text <- paste0(pc, " ~ ", formula, " | ", subject_id)
  current_formula <- as.formula(formula_text)
  
  metadata <- model.matrix(as.formula(paste0(pc, " ~ ", formula)), data = df)[,-1]
  metadata <- as.data.frame(metadata)
  y <- df[[pc]]
  X_raw <- model.matrix(~., metadata)[,-1]
  
  len_cov <- ncol(X_raw) + 1
  
  # Fit rqpd
  fit <- rqpd(formula = current_formula, data = df,
              control = quantreg::sfn.control(tmpmax = 1e8),
              panel(lambda = lambda,
                    tauw = tauw,
                    taus = taus))
  
  # Extract coefficient
  coef_fixed = fit$coef[1:(len_cov*q)]
  coef_mat = matrix(coef_fixed, nrow=len_cov, ncol=q, byrow=F)
  
  coef_random <- fit$coef[-(1:(len_cov * q))] 
  subject_levels <- levels(df[[subject_id]])  
  subject_index <- as.numeric(factor(df[[subject_id]], levels = subject_levels))
  random_mat <- matrix(coef_random, nrow = length(subject_levels), ncol = q, byrow = FALSE)
  
  # SL updated 9.27: Predict quantiles (with batch)
  Xi <- cbind(Intercept = 1, as.matrix(X_raw))
  # Fixed-effects
  Q_fixed <- Xi %*% coef_mat
  # Subject random effects
  R_subj  <- random_mat[subject_index, , drop = FALSE]
  # Full fitted conditional quantile curves
  quant_matrix <- Q_fixed + R_subj
  colnames(quant_matrix) <- quantiles
  
  # Predict quantiles (Remove target covariate)
  
  # SL updated 9.27: Set selected fixed-effect columns to 0 in the design matrix.
  # - If covariates == "all": zero ALL fixed effects (include time) → intercept-only target.
  # - Else: zero only columns whose names match `covariates` and their interactions.
  X_corrected <- X_raw
  if (identical(covariates, "all")) {
    X_corrected[,] <- 0
  } else {
    idx <- grep(paste(covariates, collapse = "|"), colnames(X_raw))
    X_corrected[, idx] <- 0
  }

  Xi_corrected <- cbind(Intercept = 1, as.matrix(X_corrected))
  # Get the predicted full quantile curves after correction
  Q_fixed_corrected <- Xi_corrected %*% coef_mat          # n × q
  R_subj_corrected  <- random_mat[subject_index, , drop = FALSE]
  quant_matrix_corrected <- Q_fixed_corrected + R_subj_corrected
  colnames(quant_matrix_corrected) <- quantiles
  
  # SL updated 9.29: Quantile matching (invert → transport)

  PC_hat <- vapply(seq_along(y), function(i) {
    # Fitted conditional quantile curve for observation i
    q_obs <- quant_matrix[i, ]         

    # Corrected quantile curve for the same observation
    q_corr <- quant_matrix_corrected[i, ]

    # --- Invert step ---
    # Find all τ grid points where the fitted quantile is ≤ the observed outcome y[i].
    match_idx <- which(q_obs <= y[i])
    
    # Left-continuous inverse:
    # take the largest τ index such that Q̂(τ | x_i) ≤ y[i].
    # If none exist (y[i] smaller than all fitted values), fall back to τ_1.
    if (length(match_idx) > 0) {
      tau_idx <- max(match_idx) 
    } else {
      tau_idx <- 1
    }

    # --- Transport step ---
    # Map the same conditional rank τ̂_i to the target quantile curve.
    # This gives the batch-corrected value for observation i.
    q_corr[tau_idx]

  }, numeric(1)) # vapply: expect a single numeric output per observation

# Save the corrected PC scores for this component into the results list
PC_hat_list[[pc]] <- PC_hat
}

# Compile all corrected PCs together
resid_PCs <- do.call(cbind, PC_hat_list)
colnames(resid_PCs) <- colnames(PCs)

# Eigen-decomposition on the corrected matrix and get the final PCs
final_PCs <- process_resids(resid_PCs, otu_tmp, cond, batchid)
```

```{r}
p_final2 <- final_PCs$PCs %>%
  mutate(Sex = ifelse(batch == 1, "Female", "Male")) %>%
  mutate(Arm = factor(ifelse(treatment == 0,'Control',"Treatment"), levels = c("Treatment","Control"))) %>%
  ggplot(aes(PC1, PC2, color = Arm, shape = `Sex`, group = `Sex`)) +
  geom_point(size = 2) +
  facet_wrap(~time, nrow = 2, scales = 'free',
             labeller = label_bquote(t[.(time-1)])) +
  theme(strip.text = element_blank()) +
  xlab(paste0('PC1 (', round(100*final_PCs$PC1_perc,2),'%)')) +
  ylab(paste0('PC2 (', round(100*final_PCs$PC2_perc,2),'%)')) +
  theme(plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
        legend.background = element_blank(), #transparent legend bg
        legend.box.background = element_blank(),
        axis.text = element_text(size = 15),
        axis.title = element_text(size = 18),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18)) +
  ggtitle('Quantile Adjusted Longitudinal PCoA ') +
  stat_ellipse(aes(group = `Sex`, lty = `Sex`)) +
  geom_text(data = annotations, aes(x = x, y = y, label = label),
            hjust = -0.2, vjust = 1.5, parse = TRUE, inherit.aes = FALSE)
p_final2
```

